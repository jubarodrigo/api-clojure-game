<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="d5ce8d47-1570-4c87-9844-cc3e03d3c633" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_core_async_0_4_500.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_core_cache_0_6_5.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_core_memoize_0_5_9.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_data_priority_map_0_0_7.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_tools_analyzer_0_6_9.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_tools_analyzer_jvm_0_7_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_tools_reader_1_0_0_beta4.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_ow2_asm_asm_all_4_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/jogo_velha/async.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/jogo_velha.iml" beforeDir="false" afterPath="$PROJECT_DIR$/jogo_velha.iml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/project.clj" beforeDir="false" afterPath="$PROJECT_DIR$/project.clj" afterDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DefaultGradleProjectSettings">
    <option name="testRunner" value="GRADLE" />
    <option name="delegatedBuild" value="true" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="ProjectId" id="1P19Vrb5clHhi7IqH4jvGftyeet" />
  <component name="PropertiesComponent">
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="cursive.last.file.extension./home/rodrigo/Documentos/ambientes/sandbox/estudo/clojure/api-clojure-game/src" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="project.propDebugger" />
  </component>
  <component name="ReplState" timestamp="1565380357548">{:repl-history {:ide [], :local [{:command &quot;(validar-linha [ 1 2 3])&quot;, :offset 24, :ns &quot;jogo-velha.core&quot;} {:command &quot;(validar-linha [ 1 1 1])&quot;, :offset 24, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn validar-linha\n  [board-row]\n  (-&gt; (set board-row)\n      (count) \n      (= 1)) \n  )&quot;, :offset 88, :ns &quot;jogo-velha.core&quot;} {:command &quot;(validar-linha [1 1 1])&quot;, :offset 23, :ns &quot;jogo-velha.core&quot;} {:command &quot;(validar-linha [1 1 2])&quot;, :offset 23, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn row-win?\n  [board-row]\n  (-&gt; (set board-row)\n      (count)\n      (= 1))\n  )&quot;, :offset 81, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn horizontal-win?\n  [board]\n  (some row-win? board)\n  )&quot;, :offset 59, :ns &quot;jogo-velha.core&quot;} {:command &quot;(horizontal-win? [[1 1 1] [1 2 3] [1 2 3]])&quot;, :offset 43, :ns &quot;jogo-velha.core&quot;} {:command &quot;(horizontal-win? [[1 2 1] [1 2 3] [1 2 3]])&quot;, :offset 43, :ns &quot;jogo-velha.core&quot;} {:command &quot;(get [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot;] 1)&quot;, :offset 21, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play 0 0 board \&quot;o\&quot;)&quot;, :offset 20, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def board1 )&quot;, :offset 12} {:command &quot;(play 0 2 board \&quot;o\&quot;)&quot;, :offset 20, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play 1 2 board \&quot;o\&quot;)&quot;, :offset 20, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play 0 0 board1 \&quot;x\&quot;)&quot;, :offset 21, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play 0 2 board1 \&quot;x\&quot;)&quot;, :offset 21, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play 0 1 board1 \&quot;x\&quot;)&quot;, :offset 21, :ns &quot;jogo-velha.core&quot;} {:command &quot;((play 0 0 board \&quot;x\&quot;) board1)&quot;, :offset 29, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play  0 1 board1 \&quot;x\&quot;)&quot;, :offset 22, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play  0 2 board1 \&quot;x\&quot; board1)&quot;, :offset 29, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play  0 2 board1 \&quot;x\&quot;)&quot;, :offset 17} {:command &quot;(board1)&quot;, :offset 8, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def board1 (play 0 0 board \&quot;x\&quot;))&quot;, :offset 33, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def board1 (play 0 1 board \&quot;x\&quot;))&quot;, :offset 33, :ns &quot;jogo-velha.core&quot;} {:command &quot;(board1 (play 0 0 board1 \&quot;x\&quot;))&quot;, :offset 30, :ns &quot;jogo-velha.core&quot;} {:command &quot;((play 0 0 board1 \&quot;x\&quot;) board1)&quot;, :offset 30, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def board1 (play 0 2 board1 \&quot;x\&quot;))&quot;, :offset 34, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def board1 (play 0 0 board1 \&quot;x\&quot;))&quot;, :offset 34, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def board1 (play 0 1 board1 \&quot;x\&quot;))&quot;, :offset 34, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def vertical-win?\n  [board]\n  (apply mapv vector board)\n  )&quot;, :offset 60, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def vertical-win?\n  [board]\n  (apply mapv vector board)\n  board\n  )&quot;, :offset 68, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def vertical-win?\n  [board]\n  (apply mapv vector board)\n  (horizontal-win? board)\n  )&quot;, :offset 86, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def vertical-win?\n  [board]\n  (apply mapv board)\n  (horizontal-win? board)\n  )&quot;, :offset 79, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn vertical-win?\n  [board]\n  (apply mapv board)\n  (horizontal-win? board)\n  )&quot;, :offset 80, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn vertical-win?\n  [board]\n  (apply mapv vector board)\n  (horizontal-win? board)\n  )&quot;, :offset 87, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn vertical-win?\n  [board]\n  (horizontal-win? (apply mapv vector board))\n  )&quot;, :offset 79, :ns &quot;jogo-velha.core&quot;} {:command &quot;(vertical-win? board)&quot;, :offset 21, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn play\n  [x y board player]\n  (if (coord-free? x y board)\n    (vector (assoc-in board [x y] player))\n    (println \&quot;Posição já utilizada\&quot;)\n    )\n  )&quot;, :offset 151, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn play\n  [x y board player]\n  (if (coord-free? x y board)\n    (apply vector (assoc-in board [x y] player))\n    (println \&quot;Posição já utilizada\&quot;)\n    )\n  )&quot;, :offset 157, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def board [])&quot;, :offset 14, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play 0 1 board \&quot;x\&quot;)&quot;, :offset 20, :ns &quot;jogo-velha.core&quot;} {:command &quot;(def board [[] [] []])&quot;, :offset 22, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn play\n  [x y board player]\n  (if (coord-free? x y board)\n    (assoc-in board [x y] player)\n    (println \&quot;Posição já utilizada\&quot;)\n    )\n  )&quot;, :offset 142, :ns &quot;jogo-velha.core&quot;} {:command &quot;board&quot;, :offset 5, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play 0 0 board \&quot;x\&quot;)&quot;, :offset 20, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play 0 3 board \&quot;x\&quot;)&quot;, :offset 20, :ns &quot;jogo-velha.core&quot;} {:command &quot;(range 10)&quot;, :offset 10, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (-&gt; (range nx))\n  )&quot;, :offset 47, :ns &quot;jogo-velha.core&quot;} {:command &quot;(new board)&quot;, :offset 11, :ns &quot;jogo-velha.core&quot;} {:command &quot;(new new-board)&quot;, :offset 15, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (as-&gt; (range nx) result\n      (map vector result)\n      )\n  )&quot;, :offset 89, :ns &quot;jogo-velha.core&quot;} {:command &quot;(docs fn)&quot;, :offset 9, :ns &quot;jogo-velha.core&quot;} {:command &quot;(doc fn)&quot;, :offset 8, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (as-&gt; (range nx) result\n        (map (fn [] \n               (map #( nil) (range ny)) \n               ) result)\n        )\n  )&quot;, :offset 152, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (as-&gt; (range nx) result\n        (map (fn [] \n               (map nil (range ny)) \n               ) result)\n        )\n  )&quot;, :offset 148, :ns &quot;jogo-velha.core&quot;} {:command &quot;(new board  3 3)&quot;, :offset 16, :ns &quot;jogo-velha.core&quot;} {:command &quot;(new-board  3 3)&quot;, :offset 16, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (as-&gt; (range nx) result\n        (map (fn []\n               (map nil (range 3))\n               ) result)\n        )\n  )&quot;, :offset 145, :ns &quot;jogo-velha.core&quot;} {:command &quot;(map nil (range 3)&quot;, :offset 18, :ns &quot;jogo-velha.core&quot;} {:command &quot;(map nil (range 3))&quot;, :offset 19, :ns &quot;jogo-velha.core&quot;} {:command &quot;(map #( nil) (range 3))&quot;, :offset 23, :ns &quot;jogo-velha.core&quot;} {:command &quot;(map #(nil) (range 3))&quot;, :offset 22, :ns &quot;jogo-velha.core&quot;} {:command &quot;(map #( nil %) (range 3))&quot;, :offset 25, :ns &quot;jogo-velha.core&quot;} {:command &quot;(map (fn [x] nil) (range 3))&quot;, :offset 28, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (as-&gt; (range nx) result\n        (map (fn []\n               (map (fn [x] nil) (range ny))\n               ) result)\n        )\n  )&quot;, :offset 155, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (as-&gt; (range nx) result\n        (map (fn [x]\n               (map (fn [x] nil) (range ny))\n               ) result)\n        )\n  )&quot;, :offset 156, :ns &quot;jogo-velha.core&quot;} {:command &quot;(new-board 30 30)&quot;, :offset 17, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (as-&gt; (range nx) result\n        (map (fn [x]\n               (map (fn [x] nil) (range ny))\n               ) result)\n        (apply vector result)\n        )\n  )&quot;, :offset 186, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx ny]\n  (as-&gt; (range nx) result\n        (map (fn [x]\n               (apply vector (map (fn [x] nil) (range ny)))\n               ) result)\n        (apply vector result)\n        )\n  )&quot;, :offset 201, :ns &quot;jogo-velha.core&quot;} {:command &quot;(new-board 3 3)&quot;, :offset 15, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play  0 0 (new-board))&quot;, :offset 23, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play  0 0 (new-board 3 3))&quot;, :offset 27, :ns &quot;jogo-velha.core&quot;} {:command &quot;(play  0 0 (new-board 3 3) \&quot;x\&quot;)&quot;, :offset 31, :ns &quot;jogo-velha.core&quot;} {:command &quot;(doc &gt;=)&quot;, :offset 8, :ns &quot;jogo-velha.core&quot;} {:command &quot;(doc =&gt;)&quot;, :offset 8, :ns &quot;jogo-velha.core&quot;} {:command &quot;(&gt;= 0 0)&quot;, :offset 8, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn traverse-win?\n  [board start stop interact]\n  (loop [c start]\n    (if (= c stop)\n      (println c)\n      (recur board (interact start) stop interact)\n      ))\n  )&quot;, :offset 168, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn traverse-win?\n  [board start stop interact]\n  (loop [c start]\n    (if (= c stop)\n      (println c)\n      (recur (interact start))\n      ))\n  )&quot;, :offset 148, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn new-board\n  [nx]\n  (as-&gt; (range nx) result\n        (map (fn [x]\n               (apply vector (map (fn [x] nil) (range nx)))\n               ) result)\n        (apply vector result)\n        )\n  )&quot;, :offset 198, :ns &quot;jogo-velha.core&quot;} {:command &quot;(clear)&quot;, :offset 7, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn traverse-win?\n  [board start stop interact]\n  (loop [c start]\n    (if (= c stop)\n      (recur (interact start))\n      (println c)\n      ))\n  )&quot;, :offset 148, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn traverse-win?\n  [board start stop interact]\n  (loop [c start]\n    (if (= c stop)\n      (println c)\n      (recur (interact c)\n      )\n    )\n   )\n  )&quot;, :offset 153, :ns &quot;jogo-velha.core&quot;} {:command &quot;(traverse-win? (new-board 3) 0 3 inc)&quot;, :offset 37, :ns &quot;jogo-velha.core&quot;} {:command &quot;(traverse-win? (new-board 3) 2 0 dec)&quot;, :offset 37, :ns &quot;jogo-velha.core&quot;} {:command &quot;(traverse-win? (new-board 3) 0 2 inc)&quot;, :offset 37, :ns &quot;jogo-velha.core&quot;} {:command &quot;(get-in (new-board 3) [[1 1] [2 2] [3 3]])&quot;, :offset 42, :ns &quot;jogo-velha.core&quot;} {:command &quot;(get-in (new-board 3) [[0 0] [1 1] [2 2]])&quot;, :offset 42, :ns &quot;jogo-velha.core&quot;} {:command &quot;(get-in (new-board 3) [0 0])&quot;, :offset 28, :ns &quot;jogo-velha.core&quot;} {:command &quot;(get-in (new-board 3) [1 1])&quot;, :offset 28, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn transversal-win?\n  [board start stop interact]\n  (loop [c start]\n    (if (= c stop)\n      c\n      (do (map board [c stop])\n          (recur (interact c)))\n      )\n    )\n  )&quot;, :offset 178, :ns &quot;jogo-velha.core&quot;} {:command &quot;(defn transversal-win?\n  [board start stop interact]\n  (loop [c start]\n    (if (= c stop)\n      \&quot;no\&quot;\n      (do (map vector board [c stop])\n          (recur (interact c)))\n      )\n    )\n  )&quot;, :offset 188, :ns &quot;jogo-velha.core&quot;} {:command &quot;(transversal-win? (new-board 3) 0 2 inc)&quot;, :offset 40, :ns &quot;jogo-velha.core&quot;} {:command &quot;(ns jogo-velha.async\n  (:require [clojure.core.async :as a :refer [&lt;! &gt;! go go-loop put!]]))\n\n(def main-chanel (a/chan))\n\n(put! main-chanel \&quot;teste asyc\&quot;)&quot;, :offset 153, :ns &quot;jogo-velha.async&quot;} {:command &quot;(def main-chanel  (a/chan 1))&quot;, :offset 29, :ns &quot;jogo-velha.async&quot;} {:command &quot;(ns jogo-velha.async\n  (:require [clojure.core.async :as a :refer [&lt;! &gt;! go go-loop put! poll!]]))\n\n(def main-chanel  (a/chan 1))\n\n(put! main-chanel \&quot;teste asyc\&quot;\n      (println \&quot;fim\&quot;)\n      )\n\n(poll! main-chanel)&quot;, :offset 212, :ns &quot;jogo-velha.async&quot;} {:command &quot;(put! main-chanel \&quot;teste asyc\&quot;\n      (println \&quot;fim\&quot;)\n      )&quot;, :offset 60, :ns &quot;jogo-velha.async&quot;} {:command &quot;(poll! main-chanel)&quot;, :offset 19, :ns &quot;jogo-velha.async&quot;} {:command &quot;(go-loop []\n  (println (&lt;! main-chanel))\n  (recur)\n  )&quot;, :offset 54, :ns &quot;jogo-velha.async&quot;} {:command &quot;(go-loop [messages []]\n  (let [new-messages [(&lt;! main-chanel)]]\n    (println messages)\n    (recur (conj messages new-messages))))&quot;, :offset 129, :ns &quot;jogo-velha.async&quot;} {:command &quot;(put! main-chanel \&quot;teste asyc\&quot;)&quot;, :offset 31, :ns &quot;jogo-velha.async&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager">
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="localhost" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="jogo_velha" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2">
        <option name="Synchronize Leiningen" enabled="true" />
        <option name="MakeProject" enabled="true" />
      </method>
    </configuration>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="d5ce8d47-1570-4c87-9844-cc3e03d3c633" name="Default Changelist" comment="" />
      <created>1565030761323</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1565030761323</updated>
    </task>
    <servers />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_ORDER" />
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>